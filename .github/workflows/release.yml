name: Release Action

on:
  workflow_dispatch:
    inputs:
      target_branches:
        description: 'Target branches'
        required: true
        default: 'master,develop'
      trigger_release:
        type: boolean
        description: 'GitHub Release'
        required: true
        default: true
      trigger_docker_release:
        type: boolean
        description: 'Docker images release'
        required: true
        default: true
      docker_version:
        description: 'Source Docker version'
        required: true
        default: 'XXXX'
      trigger_packages_release:
        type: boolean
        description: 'Packages release'
        required: true
        default: true
      package_build_numbers:
        description: 'deb/rpm/exe package build numbers'
        required: true
        default: 'DEB/RPM/EXE'
      trigger_notify:
        type: boolean
        description: 'Notify'
        required: true
        default: true
      delete_branch:
        type: boolean
        description: 'Delete release branch'
        required: true
        default: true

jobs:
  extract-version:
    name: Version retrieval
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract.outputs.version }}
    steps:
      - id: extract
        name: Extract & validate version
        shell: bash
        env:
          BRANCH: ${{ github.ref_name }}
        run: |
          if [[ "${BRANCH}" == "master" || "${BRANCH}" == "develop" ]]; then
            echo "::error::Please use a release branch (e.g., release/1.2.3) for this workflow"
            exit 1
          fi
          if [[ "${BRANCH##*/}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            version="${BASH_REMATCH[0]}"
          else
            echo "::error::Invalid version: ${BRANCH##*/} (expected vX.X.X)"
            exit 1
          fi

          echo "version=$version" >> "$GITHUB_OUTPUT"

  trigger_docker_release:
    if: ${{ github.event.inputs.trigger_docker_release == 'true' }}
    name: Trigger Docker release
    runs-on: ubuntu-latest
    needs: extract-version
    outputs:
      docker_run_id: ${{ steps.docker_release.outputs.docker_run_id }}
    env:
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
      VERSION: ${{ needs.extract-version.outputs.version }}
    steps:
      - name: Trigger Docker release
        id: docker_release
        run: |
          DOCKER_VERSION="${VERSION#v}.1"

          WORKFLOW_ID=$(gh api repos/${{ github.repository }}-buildtools/actions/workflows \
            --jq '.workflows[] | select(.path == ".github/workflows/release-docspace.yaml") | .id')

          gh api /repos/${{ github.repository }}-buildtools/actions/workflows/${WORKFLOW_ID}/dispatches -X POST \
            -f "ref=${{ github.ref_name }}" -f "inputs[release_version]=${DOCKER_VERSION}" -f "inputs[source_version]=${VERSION}.${{ github.event.inputs.docker_version }}"

          until [ -n "${DOCKER_RUN_ID}" ]; do
            DOCKER_RUN_ID=$(gh api repos/${{ github.repository }}-buildtools/actions/runs \
              --jq '.workflow_runs[] | select(.workflow_id=='"${WORKFLOW_ID}"' and (.status=="in_progress" or .status=="queued")) | .id' | head -n 1)
            sleep 5
          done

          echo "docker_run_id=${DOCKER_RUN_ID}" >> $GITHUB_OUTPUT

  trigger_packages_release:
    if: ${{ github.event.inputs.trigger_packages_release == 'true' }}
    name: Trigger Packages release
    runs-on: ubuntu-latest
    needs: extract-version
    outputs:
      deb_build_number: ${{ steps.package_release.outputs.deb_build_number }}
      rpm_build_number: ${{ steps.package_release.outputs.rpm_build_number }}
      exe_build_number: ${{ steps.package_release.outputs.exe_build_number }}
    env:
      JENKINS_URL: ${{ secrets.JENKINS_URL }}
      JENKINS_TOKEN: ${{ secrets.JENKINS_TOKEN }}
      VERSION: ${{ needs.extract-version.outputs.version }}
    steps:
      - name: Trigger Packages release
        id: package_release
        run: |
          declare -A NUM; IFS='/' read -r NUM[deb] NUM[rpm] NUM[exe] <<< "${{ github.event.inputs.package_build_numbers }}"

          for TYPE in deb rpm exe; do
            BUILD_NUM=${NUM[${TYPE}]}
            PUBLISH_JOB=$([ "$TYPE" = "exe" ] && echo "production.docspace.${TYPE}.publish" || echo "production.${TYPE}.publish")

            curl -s -S -X POST -H "Content-Length: 0" -u "${JENKINS_TOKEN}" "${JENKINS_URL}/job/appserver.${TYPE}/${BUILD_NUM}/toggleLogKeep" -o /dev/null
            [[ $(jq -r '.keepLog' <<< "$(curl -s -u "${JENKINS_TOKEN}" "${JENKINS_URL}/job/appserver.${TYPE}/${BUILD_NUM}/api/json")") == true ]] || echo "::error:: [${TYPE}] LogKeep not applied"
            curl -s -S -X POST -u "${JENKINS_TOKEN}" -d "description=${VERSION}.${BUILD_NUM}" "${JENKINS_URL}/job/appserver.${TYPE}/${BUILD_NUM}/submitDescription" -o /dev/null
            [[ $(jq -r '.description' <<< "$(curl -s -u "${JENKINS_TOKEN}" "${JENKINS_URL}/job/appserver.${TYPE}/${BUILD_NUM}/api/json")") != "" ]] || echo "::error:: [${TYPE}] Description not set"

            curl -s -S -X POST -H "Content-Length: 0" -u "${JENKINS_TOKEN}" "${JENKINS_URL}/job/${PUBLISH_JOB}/$([ "${TYPE}" = "exe" ] && echo "build" || echo "buildWithParameters")" -o /dev/null
            sleep 10
            [[ $(jq -r '.building' <<< "$(curl -s -u "${JENKINS_TOKEN}" "${JENKINS_URL}/job/${PUBLISH_JOB}/lastBuild/api/json")") == true ]] && echo "[${TYPE}] Build started" || echo "::error:: [${TYPE}] Build not started"
            echo "${TYPE}_build_number=$(curl -s -S -L -u "${JENKINS_TOKEN}" "${JENKINS_URL}/job/${PUBLISH_JOB}/lastBuild/api/json" | jq '.number')" >> "$GITHUB_OUTPUT"
          done

  create_and_merge_pr:
    name: Create/merge PRs ${{ matrix.repo }}
    runs-on: ubuntu-latest
    needs: extract-version
    strategy:
      matrix:
        repo: [ "DocSpace", "DocSpace-buildtools", "DocSpace-client", "DocSpace-server" ]
    steps:
      - name: Set up Gitea CLI
        run: |
          sudo curl -sL "https://dl.gitea.com/tea/main/tea-main-linux-amd64" -o /usr/bin/tea
          sudo chmod +x /usr/bin/tea
          tea login add --url ${{ secrets.GITEA_HOST }} --token ${{ secrets.GITEA_TOKEN }}

      - name: Check branch existence
        run: |
          check_branch(){
            GIT_OUTPUT=$(git ls-remote --heads "https://${{ secrets.GITEA_TOKEN }}@${{ secrets.GITEA_HOST }}/${{ github.repository_owner }}/${{ matrix.repo }}" "refs/heads/${1%\*}*")
            [[ -z ${GIT_OUTPUT} ]] && { echo "::error::Branch '$1' does not exist in repository ${{ matrix.repo }}"; [[ $1 == changelog/* ]] && return 0 || return 1; }
            BRANCH_NAME=$(awk '{ sub("refs/heads/","",$2); print $2 }' <<<"$GIT_OUTPUT" | sort -V | tail -n1)
            echo "Branch $BRANCH_NAME found"
            [[ ${1} == changelog/* ]] && echo "CHANGELOG_BRANCH=${BRANCH_NAME}" >> "$GITHUB_ENV" || true
          }

          IFS=',' read -ra BRANCHES <<< "${{ github.event.inputs.target_branches }}"
          for BRANCH in "${{ github.ref_name }}" "${BRANCHES[@]}"; do
            check_branch "$BRANCH" || exit 1
          done
          [ "${{ matrix.repo }}" = "DocSpace" ] && check_branch 'changelog/*' || true

      - name: Check commits difference
        run: |
          git clone https://${{ secrets.GITEA_TOKEN }}@${{ secrets.GITEA_HOST }}/${{ github.repository_owner }}/${{ matrix.repo }}
          cd ${{ matrix.repo }} && git fetch --quiet --all

          check_commits_difference(){
            HEAD=$1; BASE=$2; FLAG=${3}
            COMMITS=$(git log origin/${BASE}..origin/${HEAD} --oneline)
            if [ -z "$COMMITS" ]; then
              echo "::warning::No changes between '${HEAD}' and '${BASE}'. Skipping PR."
              echo "${FLAG}=true" >> $GITHUB_ENV
            fi
          }

          sanitize(){ sed -E 's/[^[:alnum:]_]+/_/g;s/^[0-9]/_&/;s/.*/\U&/'; }
          IFS=',' read -ra BRANCHES <<< "${{ github.event.inputs.target_branches }}"
          for BRANCH in "${BRANCHES[@]}"; do
            check_commits_difference "${{ github.ref_name }}" "${BRANCH}" "SKIP_PR_$(sanitize <<<"$BRANCH")"
          done

          if [[ -n "${{ env.CHANGELOG_BRANCH }}" ]]; then
            check_commits_difference "${{ env.CHANGELOG_BRANCH }}" "master" "SKIP_PR_$(sanitize <<<"${{ env.CHANGELOG_BRANCH }}")"
          fi

      - name: Create Pull Request
        run: |
          REPO="${{ github.repository_owner }}/${{ matrix.repo }}"

          create_pr() {
            local HEAD="$1" BASE="$2" FLAG="$3"
            [[ "${!FLAG}" == "true" ]] && { echo "â†· Skip ${HEAD} â†’ ${BASE} (${FLAG}=true)"; return; }
            echo ">>> Creating PR: head='${HEAD}' â†’ base='${BASE}'"

            EXISTING=$(tea pr list --login "${{ secrets.GITEA_HOST }}" \
              --repo "${REPO}" --state open --fields index,head,base --output json \
              | jq -r --arg H "${HEAD}" --arg B "${BASE}" '.[] | select(.head == $H and .base == $B) | .index')

            if [[ -n "${EXISTING}" ]]; then
              echo "â†’ PR #${EXISTING} already exists for ${HEAD} â†’ ${BASE}."
            else
              tea pr create --repo "${REPO}" --base "${BASE}" --head "${HEAD}" \
                -t "Merge ${HEAD} into ${BASE}" \
                --description "Automatically created by Release Action" \
                || echo "::error:: Failed to create PR for ${HEAD} â†’ ${BASE}"
            fi
          }

          sanitize(){ sed -E 's/[^[:alnum:]_]+/_/g;s/^[0-9]/_&/;s/.*/\U&/'; }
          IFS=, read -ra BRANCHES <<< "${{ github.event.inputs.target_branches }}"
          for BASE in "${BRANCHES[@]}"; do
            create_pr "${{ github.ref_name }}" "$BASE" "SKIP_PR_$(sanitize <<<"$BASE")"
          done

          if [[ -n "${{ env.CHANGELOG_BRANCH }}" ]]; then
            create_pr "${{ env.CHANGELOG_BRANCH }}" "master" "SKIP_PR_$(sanitize <<<"${{ env.CHANGELOG_BRANCH }}")"
          fi

      - name: Auto merge Pull Request
        if: ${{ env.SKIP_PR != 'true' || env.SKIP_PR_DEVELOP != 'true' || env.SKIP_PR_CHANGELOG != 'true' }}
        run: |
          REPO="${{ github.repository_owner }}/${{ matrix.repo }}"

          merge() {
            HEAD="$1"; BASE="$2"; FLAG="$3"; MERGE_STYLE="${4:-merge}"
            [[ "${!FLAG}" == "true" ]] && { echo "â†· Skip ${HEAD} â†’ ${BASE} (${FLAG}=true)"; return; }
            echo ">>> Processing PR: head='$HEAD' â†’ base='${BASE}' in ${REPO}"
            PR_NUMBER=$(timeout 60 bash -c "
              while :; do
                num=\$(tea pr list --login \"${{ secrets.GITEA_HOST }}\" \
                  --repo \"${REPO}\" --state open --fields index,head,base --output json \
                  | jq -r --arg H \"${HEAD}\" --arg B \"${BASE}\" '.[] | select(.head==\$H and .base==\$B) | .index')
                [[ -n \$num && \$num != UNKNOWN ]] && { echo \$num; exit; }
                sleep 2
              done
            ")

            if [[ -z "$PR_NUMBER" ]]; then
              echo "::error:: Failed to find open PR for head='$HEAD' â†’ base='${BASE}'"
              exit 1
            fi

            MERGEABLE=$(tea pr list --login "${{ secrets.GITEA_HOST }}" --repo "${REPO}" \
              --state all --fields index,mergeable --output json \
              | jq -r --arg PR "$PR_NUMBER" '.[] | select(.index==$PR) | .mergeable')

            if [[ "$MERGEABLE" == "true" ]]; then
              tea pr merge --repo "${REPO}" --style "${MERGE_STYLE}" --title  "Merge ${HEAD} into ${BASE}" "${PR_NUMBER}" \
                || echo "::error:: Failed to merge PR #${PR_NUMBER} for ${HEAD} â†’ ${BASE}"
            else
              echo "::warning:: PR #$PR_NUMBER is not mergeable or has conflicts."
            fi
          }

          sanitize(){ sed -E 's/[^[:alnum:]_]+/_/g;s/^[0-9]/_&/;s/.*/\U&/'; }
          IFS=, read -ra BRANCHES <<<"${{ github.event.inputs.target_branches }}"
          for BASE in "${BRANCHES[@]}"; do
            merge "${{ github.ref_name }}" "$BASE" "SKIP_PR_$(sanitize <<<"$BASE")"
          done

          if [[ -n "${{ env.CHANGELOG_BRANCH }}" ]]; then
            merge "${{ env.CHANGELOG_BRANCH }}" "master" "SKIP_PR_$(sanitize <<<"${{ env.CHANGELOG_BRANCH }}")" "squash"
          fi

  release:
    if: ${{ github.event.inputs.trigger_release == 'true' }}
    name: Release ${{ matrix.repo }}
    runs-on: ubuntu-latest
    needs: [create_and_merge_pr, extract-version]
    env:
      VERSION: ${{ needs.extract-version.outputs.version }}
    strategy:
      fail-fast: false
      matrix:
        repo: [ "DocSpace", "DocSpace-buildtools", "DocSpace-client", "DocSpace-server" ]
    steps:
      - name: Set up Gitea CLI
        run: |
          sudo curl -sL "https://dl.gitea.com/tea/main/tea-main-linux-amd64" -o /usr/bin/tea
          sudo chmod +x /usr/bin/tea
          tea login add --url ${{ secrets.GITEA_HOST }} --token ${{ secrets.GITEA_TOKEN }}

      - name: Wait for all PR merges across repositories
        env:
          REPOS: "DocSpace DocSpace-client DocSpace-server DocSpace-buildtools"
        run: |
          echo "Waiting for PR merges in all repositories..."

          sanitize(){ sed -E 's/[^[:alnum:]_]+/_/g;s/^[0-9]/_&/;s/.*/\U&/'; }
          IFS=, read -ra BRANCHES <<<"${{ github.event.inputs.target_branches }}"
          for BASE in "${BRANCHES[@]}"; do
            FLAG="SKIP_PR_$(sanitize <<<"$BASE")"
            [[ "${!FLAG}" == "true" ]] && { echo "â†· Skip ${{ github.ref_name }} â†’ ${BASE} (${FLAG}=true)"; continue; }
            BASE_BRANCHES+=("${BASE}")
          done
          
          while :; do
            MERGED=0
            TOTAL=$(( $(set -- ${REPOS}; echo $#) * ${#BASE_BRANCHES[@]} ))
            for REPO in ${REPOS}; do
              echo "â”œ ${REPO}"
              for BASE in "${BASE_BRANCHES[@]}"; do
                PR_JSON=$(tea pr list --login ${{ secrets.GITEA_HOST }} --repo ${{ github.repository_owner }}/${REPO} \
                  --state all --fields head,base,state,url --output json \
                  | jq -c --arg head "${{ github.ref_name }}" --arg base "${BASE}" \
                  '[.[]|select(.head==$head and .base==$base)] | if length>0 then .[0] else {state: "not_found", url: ""} end')
                PR_STATE=$(echo "${PR_JSON}" | jq -r '.state') 

                [[ "${PR_STATE}" == merged || "${PR_STATE}" == "closed" ]] && { MERGED=$((MERGED + 1)); echo "â”‚  â”œ ${BASE} âœ… ${PR_STATE}"; } || { echo "â”‚  â”œ ${BASE} âŒ ${PR_STATE}"; }
                [ "${PR_STATE}" = "not_found" ] && TOTAL=$(( TOTAL - 1 ));
              done
            done
            [ "${MERGED}" -eq "${TOTAL}" ] && break || echo "${MERGED}/${TOTAL} PR(s) merged. Waiting for the rest..."
            printf '%.0s-' {1..48}; echo
            sleep 5
          done

      - name: Checkout repository ${{ matrix.repo }}
        run: |
          git clone https://${{ secrets.GITEA_TOKEN }}@${{ secrets.GITEA_HOST }}/${{ github.repository_owner }}/${{ matrix.repo }} --recurse-submodules
          cd ${{ matrix.repo }}

      - name: Update submodules (DocSpace only)
        if: ${{ matrix.repo == 'DocSpace' }}
        working-directory: ${{ matrix.repo }}
        run: |
          git pull --recurse-submodules
          git submodule update --remote --merge
          if [ -n "$(git status --porcelain)" ]; then
            git config --global user.name "github-actions[bot]"
            git config --global user.email "github-actions[bot]@users.noreply.github.com"
            git commit -am "Update submodules"
            git push origin HEAD
          else
            echo "::warning::No submodule changes detected."
          fi

      - name: Create Tag
        working-directory: ${{ matrix.repo }}
        run: |
          TAG_NAME=${{ env.VERSION }}$([ "${{ matrix.repo }}" != "DocSpace" ] && echo '-server' || echo '')
          git fetch --tags
          if git rev-parse "${TAG_NAME}" >/dev/null 2>&1; then
            echo "::warning::Tag ${TAG_NAME} already exists. Skipping tag creation."
          else
            git config --global user.name "github-actions[bot]"
            git config --global user.email "github-actions[bot]@users.noreply.github.com"
            git tag ${TAG_NAME} -m "${TAG_NAME}"
            git push origin ${TAG_NAME}
          fi
        
      - name: Create Release (DocSpace only)
        if: ${{ matrix.repo == 'DocSpace' }}
        uses: softprops/action-gh-release@v2
        with:
          token: ${{ secrets.GH_TOKEN }}
          tag_name: ${{ env.VERSION }}
          name: ${{ env.VERSION }}
          body: See changes at [CHANGELOG.md](${{ github.server_url }}/${{ github.repository }}/blob/master/CHANGELOG.md)
          draft: false
          prerelease: false

  notify:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [ release, extract-version, trigger_docker_release, trigger_packages_release ]
    if: ${{ github.event.inputs.trigger_notify == 'true' }}
    env:
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
    steps:
      - name: Notify Release
        env:
          VERSION: ${{ needs.extract-version.outputs.version }}
          REPOS: "DocSpace DocSpace-client DocSpace-server DocSpace-buildtools"
          DOCKER_RUN_ID: ${{ needs.trigger_docker_release.outputs.docker_run_id }}
          DEB_BUILD_NUMBER: ${{ needs.trigger_packages_release.outputs.deb_build_number }}
          RPM_BUILD_NUMBER: ${{ needs.trigger_packages_release.outputs.rpm_build_number }}
          EXE_BUILD_NUMBER: ${{ needs.trigger_packages_release.outputs.exe_build_number }}
        run: |
          JQ_TARGET=$([ "${{ github.event.inputs.trigger_release }}" = "true" ] && echo "Release" || echo "Create/merge PR")
          JQ_FILTER=".jobs[] | select(.name | startswith(\"${JQ_TARGET}\")) | \"\\(.name | sub(\"^${JQ_TARGET}s? ?\"; \"\")) \\(.conclusion)\""
          JOB_OUTPUT=$(gh api "repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs" --jq "${JQ_FILTER}")

          for REPO in ${REPOS}; do
            [[ "${JOB_OUTPUT}" =~ "${REPO} success" ]] && SUCCESS=$((SUCCESS+1)) && EMOJI="ðŸŸ¢" || EMOJI="ðŸ”´"
            STATUS+=$'\n'"${EMOJI} [${REPO}](${{ github.server_url }}/${{ github.repository_owner }}/${REPO})"
          done

          MESSAGE="\[${SUCCESS:-0}/$(echo $REPOS | wc -w)] ${{ github.ref_name }} â†’ ${{ github.event.inputs.target_branch }} ${STATUS}"
          if ${{ github.event.inputs.trigger_docker_release == 'true' }} || ${{ github.event.inputs.trigger_packages_release == 'true' }}; then
            MESSAGE+=$'\n'$'\n''Releases: '
            if ${{ github.event.inputs.trigger_docker_release == 'true' }}; then
              MESSAGE+='[Docker](${{ github.server_url }}/${{ github.repository }}-buildtools/actions/runs/${{ env.DOCKER_RUN_ID }}) | '
            fi
            if ${{ github.event.inputs.trigger_packages_release == 'true' }}; then
              MESSAGE+='[DEB](${{ secrets.JENKINS_URL }}/job/production.deb.publish/${{ env.DEB_BUILD_NUMBER }}) | '
              MESSAGE+='[RPM](${{ secrets.JENKINS_URL }}/job/production.rpm.publish/${{ env.RPM_BUILD_NUMBER }}) | '
              MESSAGE+='[EXE](${{ secrets.JENKINS_URL }}/job/production.docspace.exe.publish/${{ env.EXE_BUILD_NUMBER }})'
            fi
          fi

          JSON_PAYLOAD=$(jq -n --arg CHAT_ID "${{ secrets.TELEGRAM_TEAM_CHAT_ID }}" --arg TEXT "${MESSAGE}" \
            '{chat_id: $CHAT_ID, text: $TEXT, parse_mode: "Markdown", disable_web_page_preview: true}')
          TEAM_CHAT_RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMessage" \
            -H "Content-Type: application/json" -d "${JSON_PAYLOAD}")
          echo "${TEAM_CHAT_RESPONSE}" | jq -e '.ok' > /dev/null || { echo "::error:: Error sending to TEAM CHAT - $(echo "${TEAM_CHAT_RESPONSE}" | jq -r '.description')" >&2; exit 1; }

          if "${{ github.event.inputs.trigger_release }}" = "true" && ${{ github.event.inputs.trigger_docker_release == 'true' }} && ${{ github.event.inputs.trigger_packages_release == 'true' }}; then
            RELEASE_NOTIFICATION_CHAT_RESPONSE=$(curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMessage" \
              -d chat_id=${{ secrets.TELEGRAM_RELEASE_NOTIFICATION_CHAT_ID }} -d parse_mode=Markdown \
              -d "text=ONLYOFFICE DocSpace [${{ env.VERSION }}](${{ github.server_url }}/${{ github.repository }}/blob/master/CHANGELOG.md) for Docker, Linux and Windows has been released")
            echo "${RELEASE_NOTIFICATION_CHAT_RESPONSE}" | jq -e '.ok' > /dev/null || { echo "::error:: Error sending to RELEASE NOTIFICATION CHAT - $(echo "${RELEASE_NOTIFICATION_CHAT_RESPONSE}" | jq -r '.description')" >&2; exit 1; }
          fi

  delete-branch:
    name: Delete release branch
    needs: [ release, notify ]
    if: ${{ github.event.inputs.delete_branch == 'true' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        repo: [ "DocSpace", "DocSpace-buildtools", "DocSpace-client", "DocSpace-server" ]
    steps:
      - name: Delete release branch
        env:
          BRANCH: ${{ github.ref_name }}
        run: |
          GITEA_API_URL="https://${{ secrets.GITEA_HOST }}/api/v1/repos/${{ github.repository_owner }}/${{ matrix.repo }}/branches/${BRANCH//\//%2F}"
          if curl -sfH "Authorization: token ${{ secrets.GITEA_TOKEN }}" "${GITEA_API_URL}" -o /dev/null; then
            if curl -sf -X DELETE -H "Authorization: token ${{ secrets.GITEA_TOKEN }}" "${GITEA_API_URL}"; then
              echo "Branch '${BRANCH}' successfully deleted in ${{ matrix.repo }}."
            else
              echo "::error:: Error deleting branch in ${{ matrix.repo }}: HTTP status $(curl -s -o /dev/null -w '%{http_code}' -X DELETE -H \"Authorization: token ${{ secrets.GITEA_TOKEN }}\" \"${GITEA_API_URL}\")" >&2 && exit 1
            fi
          else
            echo "::warning:: Branch '${BRANCH}' not found in ${{ matrix.repo }}." >&2 && exit 1
          fi
